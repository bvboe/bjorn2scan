from logging_config import setup_logging
setup_logging()
from flask import Flask, request, Response
import os
import json
from vulnerability_coordinator import init_scanner, get_namespaces, get_image_details, get_image_vulnerabilties, get_image_sbom, rescan_all_images, reset_container_cache, get_image_summary, get_container_distro_summary, get_image_scan_status, get_node_distro_summary, get_node_scan_status, get_node_details, reset_node_cache, rescan_all_nodes, get_filters, get_vulnerability_details_by_image, get_vulnerability_details_by_pod, get_vulnerability_summary_by_node_ii, get_vulnerability_summary_by_cve_ii, get_sbom_summary_ii, get_scanner_configuration, get_vulnerability_details, get_sbom_details
from file_manager import load_sbom_full, load_vulnerability_scan_full
import csv
import io
from metrics import generate_metrics
from api_cache import ApiCache, NODE_CACHE_TYPE, IMAGE_CACHE_TYPE
import logging
from functools import partial

logger = logging.getLogger(__name__)
POD_NAMESPACE=os.getenv("POD_NAMESPACE")
CLUSTER_NAME=os.getenv("CLUSTER_NAME")
API_CACHE = ApiCache()

logger.info(f"Starting Vulnerability Coordinator")

init_scanner()
app = Flask(__name__)

def sort_vulnerability_list(vulnerabilities, sort_field):
    # Add extra data to get sorting right
    severityMapping={
        "Critical": "1",
        "High": "2",
        "Medium": "3",
        "Low": "4",
        "Negligible": "5",
        "Unknown": "6"
    }
    for v in vulnerabilities:
        v['org_vulnerability_severity'] = v['vulnerability_severity']
        v['vulnerability_severity'] = severityMapping[v['org_vulnerability_severity']]
    # Do the sort
    vulnerabilities.sort(key=partial(sort_scanned_item, sort_field=sort_field, default_sort_fields=["vulnerability_severity", "vulnerability_id", "artifact_name", "artifact_version"]))
    # Remove the temporary data
    for v in vulnerabilities:
        v['vulnerability_severity'] = v['org_vulnerability_severity']
        del v['org_vulnerability_severity']

    return vulnerabilities

def _normalize(v):
    """Normalize values for consistent sorting."""
    if isinstance(v, (int, float)):
        return v
    if v is None:
        return ""  # place missing strings after real values in tiebreakers
    return str(v).lower()

def _desc_transform(val):
    """
    Transform a value so that normal ascending sort yields a descending
    effect for that field. Works for numbers and strings.
    """
    if isinstance(val, (int, float)):
        return -val
    # Invert codepoints for reverse lexicographic order (works for Unicode)
    return "".join(chr(0x10FFFF - ord(c)) for c in val)

def sort_scanned_item(item, sort_field, default_sort_fields):
    """
    Build a tuple key like:
      (status_rank, [optional explicit sort field], default_field_1, default_field_2, ...)
    so Python's ascending sort achieves the desired ordering.
    - If sort_field is None/empty or missing in item -> ignore it, use defaults.
    - If sort_field ends with '.desc' -> sort that field descending.
    """
    STATUS_ORDER = {
        "COMPLETE": 1,
        "SCANNING": 2,
        "NO_SCAN_AVAILABLE": 3,
        "SCAN_FAILED": 4,
        "TO_BE_SCANNED": 5,
    }
    status_rank = STATUS_ORDER.get(item.get("scan_status"), 999)

    # Build the default tiebreaker tuple once
    default_tail = tuple(_normalize(item.get(f)) for f in default_sort_fields)

    # If sort_field isn't set, use just (status -> defaults)
    if not sort_field:
        return (status_rank, *default_tail)

    # Parse possible ".desc"
    descending = False
    if sort_field.endswith(".desc"):
        sort_field = sort_field[:-5]
        descending = True

    # If the field isn't present, fall back to defaults
    if sort_field not in item:
        return (status_rank, *default_tail)

    # Normalize the selected field and apply descending transform if needed
    selected = _normalize(item.get(sort_field))
    if descending:
        selected = _desc_transform(selected)

    # Final key: status, then explicit field, then default fields
    return (status_rank, selected, *default_tail)

def generate_csv_response(file_name, header_row, data_collection, to_csv_row_function):
    logger.debug("generate_csv_response({file_name}...)")
    buffer = io.StringIO()
    writer = csv.writer(buffer)

    # Write header row
    writer.writerow(header_row)

    # Write data        
    for row in data_collection:
        csv_row = to_csv_row_function(row)
        writer.writerow(csv_row)

    csv_data = buffer.getvalue()
    buffer.close()
    response = Response(csv_data, mimetype='text/csv')
    response.headers["Content-Disposition"] = "attachment; filename=" + file_name
    return response

@app.route("/api/")
def api_root():
    result = {
        "result": "success"
    }
    logger.debug(f"api_root: {result}")
    return result

@app.route("/api/clustername")
def cluster_name():
    logger.debug(f"clustername: {CLUSTER_NAME}")
    return CLUSTER_NAME

@app.route("/api/namespaces")
def namespaces():
    logger.debug("namespaces()")
    return get_namespaces()

def request_arg_to_set(arg):
    if arg is not None:
        return set(arg.split(","))
    else:
        return set()
    
def vulnerability_summary_image_row_to_csv(row):
    if row['scan_status'] == "COMPLETE":
        return [
                    row['image'],
                    row['image_id'],
                    row['num_instances'],
                    row['scan_status'],
                    row['cves_critical'],
                    row['cves_high'],
                    row['cves_medium'],
                    row['cves_low'],
                    row['cves_negligible'],
                    row['cves_unknown'],
                    row['total_risk'],
                    row['known_exploits'],
                    row['number_of_packages']
                ]
    else:
        return [
                    row['image'],
                    row['image_id'],
                    row['num_instances'],
                    row['scan_status']
                ]

@app.route("/api/vulnsummary/image")
def vulnerability_summary_image():
    namespace_filter = request_arg_to_set(request.args.get('namespace'))
    fixstatus_filter = request_arg_to_set(request.args.get('fixstatus'))
    packagetype_filter = request_arg_to_set(request.args.get('packagetype'))
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"vulnerability_summary_image({namespace_filter}, {fixstatus_filter}, {packagetype_filter}, {output})")
    result = API_CACHE.get_or_set_json("api-get_vulnerability_details_by_image", IMAGE_CACHE_TYPE, get_vulnerability_details_by_image)

    # Filter out data by namespace and figure out number of instances
    filtered_result = []
    for r in result:
        if len(namespace_filter) == 0:
            count = len(r['instances'])
            del r['instances']
            r['num_instances'] = count
            filtered_result.append(r)
        else:
            count = 0
            for i in r['instances']:
                if i['namespace'] in namespace_filter:
                    count = count + 1
            if count > 0:
                del r['instances']
                r['num_instances'] = count
                filtered_result.append(r)
    result = filtered_result

    for r in result:
        if r['scan_status'] == "COMPLETE":
            # Go through SBOM statistics and figure out number of packages
            package_counter = 0
            for s in r['sbom_statistics']:
                if len(packagetype_filter) == 0 or s['type'] in packagetype_filter:
                    package_counter = package_counter + s['count']
            r['number_of_packages'] = package_counter

            # Create a vulnerability summary
            r['cves_critical'] = 0
            r['cves_high'] = 0
            r['cves_low'] = 0
            r['cves_medium'] = 0
            r['cves_negligible'] = 0
            r['cves_unknown'] = 0
            r['known_exploits'] = 0
            r['total_risk'] = 0
            
            for v in r['vulnerability_statistics']:
                severity = v['severity'].lower()
                if (len(fixstatus_filter) == 0 or v['state'] in fixstatus_filter) and (len(packagetype_filter) == 0 or v['type'] in packagetype_filter):
                    r['cves_' + severity] = r['cves_' + severity] + v['count']
                    r['known_exploits'] = r['known_exploits'] + v['known_exploits']
                    r['total_risk'] = r['total_risk'] + v['total_risk']

        del r['sbom_statistics']
        del r['vulnerability_statistics']

    # Sort before returning result
    result.sort(key=partial(sort_scanned_item, sort_field=sort_field, default_sort_fields=["image"]))

    if output == "csv":
        header_row = ["image", 
                        "image_id", 
                        "num_instances", 
                        "scan_status", 
                        "cves_critical", 
                        "cves_high", 
                        "cves_medium", 
                        "cves_low", 
                        "cves_negligible", 
                        "cves_unknown", 
                        "total_risk", 
                        "known_exploits", 
                        "number_of_packages"
                        ]        
        return generate_csv_response("image-summary.csv", header_row, result, vulnerability_summary_image_row_to_csv)
    else:
        return result

def vulnerability_summary_cve_row_to_csv(row):
    return [
                row['vulnerability_severity'],
                row['vulnerability_id'],
                row['artifact_name'],
                row['artifact_version'],
                row['vulnerability_fix_versions'],
                row['vulnerability_fix_state'],
                row['artifact_type'],
                row['vulnerability_risk'],
                row['vulnerability_known_exploits'],
                row['image_count']
            ]

@app.route("/api/vulnsummary/cveii")
def vulnerability_summary_cve_ii():
    namespace_filter = request_arg_to_set(request.args.get('namespace'))
    fixstatus_filter = request_arg_to_set(request.args.get('fixstatus'))
    packagetype_filter = request_arg_to_set(request.args.get('packagetype'))
    severity_filter = request_arg_to_set(request.args.get('severity'))
    sort_field = request.args.get('sort')
    output = request.args.get('output')

    result = get_vulnerability_summary_by_cve_ii()

    new_result = []
    for r in result:
        if (len(fixstatus_filter) == 0 or r['vulnerability_fix_state'] in fixstatus_filter) and (len(packagetype_filter) == 0 or r['artifact_type'] in packagetype_filter) and (len(severity_filter) == 0 or r['vulnerability_severity'] in severity_filter):
            namespace_instances = r['namespace_instances']
            tmp_set = set()
            for namespace, image_set in namespace_instances.items():
                if len(namespace_filter) == 0 or namespace in namespace_filter:
                    tmp_set.update(image_set)

            counter = len(tmp_set)
            if counter > 0:
                del r['namespace_instances']
                r['image_count'] = counter
                new_result.append(r)

    # Sort before returning result
    new_result = sort_vulnerability_list(new_result, sort_field)

    if output == "csv":
        header_row = [
                    "vulnerability_severity",
                    "vulnerability_id",
                    "artifact_name",
                    "artifact_version",
                    "vulnerability_fix_versions",
                    "vulnerability_fix_state",
                    "artifact_type",
                    "risk", 
                    "known_exploits", 
                    "image_count"
                    ]        
        return generate_csv_response("cve-summary.csv", header_row, new_result, vulnerability_summary_cve_row_to_csv)
    else:
        return new_result

def vulnerability_summary_node_ii_row_to_csv(row):
    if row['scan_status'] == "COMPLETE":
        return [
                    row['node_name'],
                    row['scan_status'],
                    row['distro_id'],
                    row['distro_name'],
                    row['distro_display_name'],
                    row['cves_critical'],
                    row['cves_high'],
                    row['cves_medium'],
                    row['cves_low'],
                    row['cves_negligible'],
                    row['cves_unknown'],
                    row['total_risk'],
                    row['known_exploits'],
                    row['number_of_packages']
                ]
    else:
        return [
                    row['node_name'],
                    row['scan_status']
                ]

@app.route("/api/vulnsummary/nodeii")
def api_vulnerability_summary_node_ii():
    fixstatus_filter = request_arg_to_set(request.args.get('fixstatus'))
    packagetype_filter = request_arg_to_set(request.args.get('packagetype'))
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"api_vulnerability_summary_node_ii({fixstatus_filter}, {packagetype_filter}, {output})")

    #result = get_vulnerability_summary_by_node_ii()
    result = API_CACHE.get_or_set_json("api-get_vulnerability_summary_by_node", NODE_CACHE_TYPE, get_vulnerability_summary_by_node_ii)

    for r in result:
        if r['scan_status'] == "COMPLETE":
            # Go through SBOM statistics and figure out number of packages
            package_counter = 0
            for s in r['sbom_statistics']:
                if len(packagetype_filter) == 0 or s['type'] in packagetype_filter:
                    package_counter = package_counter + s['count']
            r['number_of_packages'] = package_counter

            # Create a vulnerability summary
            r['cves_critical'] = 0
            r['cves_high'] = 0
            r['cves_low'] = 0
            r['cves_medium'] = 0
            r['cves_negligible'] = 0
            r['cves_unknown'] = 0
            r['known_exploits'] = 0
            r['total_risk'] = 0

            for v in r['vulnerability_statistics']:
                severity = v['severity'].lower()
                if (len(fixstatus_filter) == 0 or v['state'] in fixstatus_filter) and (len(packagetype_filter) == 0 or v['type'] in packagetype_filter):
                    r['cves_' + severity] = r['cves_' + severity] + v['count']
                    r['known_exploits'] = r['known_exploits'] + v['known_exploits']
                    r['total_risk'] = r['total_risk'] + v['total_risk']

        del r['sbom_statistics']
        del r['vulnerability_statistics']

    # Sort before returning result
    result.sort(key=partial(sort_scanned_item, sort_field=sort_field, default_sort_fields=["node_name"]))

    if output == "csv":
        header_row = ["node_name", 
                        "scan_status", 
                        "distro_id",
                        "distro_name",
                        "distro_display_name",
                        "cves_critical", 
                        "cves_high", 
                        "cves_medium", 
                        "cves_low", 
                        "cves_negligible", 
                        "cves_unknown", 
                        "total_risk", 
                        "known_exploits", 
                        "number_of_packages"
                        ]        
        return generate_csv_response("node-summary.csv", header_row, result, vulnerability_summary_node_ii_row_to_csv)
    else:
        return result

def pod_summary_row_to_csv(row):
    if row['scan_status'] == "COMPLETE":
        return [
                    row['namespace'],
                    row['pod_name'],
                    row['container_name'],
                    row['image'],
                    row['image_id'],
                    row['scan_status'],
                    row['vulnarbility_summary']['by_severity']['critical'],
                    row['vulnarbility_summary']['by_severity']['high'],
                    row['vulnarbility_summary']['by_severity']['medium'],
                    row['vulnarbility_summary']['by_severity']['low'],
                    row['vulnarbility_summary']['by_severity']['negligible'],
                    row['vulnarbility_summary']['by_severity']['unknown'],
                    row['vulnarbility_summary']['by_status']['fixed'],
                    row['vulnarbility_summary']['by_status']['not_fixed'],
                    row['vulnarbility_summary']['by_status']['unknown'],
                    row['vulnarbility_summary']['by_status']['wont_fix'],
                    row['vulnarbility_summary']['number_of_packages']
                ]
    else:
        return [
                    row['namespace'],
                    row['pod_name'],
                    row['container_name'],
                    row['image'],
                    row['image_id'],
                    row['scan_status']
                ]

def vulnerability_summary_pod_row_to_csv(row):
    if row['scan_status'] == "COMPLETE":
        return [
                    row['namespace'],
                    row['pod_name'],
                    row['container_name'],
                    row['image'],
                    row['image_id'],
                    row['scan_status'],
                    row['cves_critical'],
                    row['cves_high'],
                    row['cves_medium'],
                    row['cves_low'],
                    row['cves_negligible'],
                    row['cves_unknown'],
                    row['total_risk'],
                    row['known_exploits'],
                    row['number_of_packages']
                ]
    else:
        return [
                    row['namespace'],
                    row['pod_name'],
                    row['container_name'],
                    row['image'],
                    row['image_id'],
                    row['scan_status']
                ]

@app.route("/api/vulnsummary/pod")
def vulnerability_summary_pod():
    namespace_filter = request_arg_to_set(request.args.get('namespace'))
    fixstatus_filter = request_arg_to_set(request.args.get('fixstatus'))
    packagetype_filter = request_arg_to_set(request.args.get('packagetype'))
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"vulnerability_summary_pod({namespace_filter}, {fixstatus_filter}, {packagetype_filter}, {output})")
    result = API_CACHE.get_or_set_json("api-get_vulnerability_details_by_pod", IMAGE_CACHE_TYPE, get_vulnerability_details_by_pod)

    # Apply namespace filter
    if len(namespace_filter) > 0:
        filtered_result = []
        for r in result:
            if r['namespace'] in namespace_filter:
                filtered_result.append(r)
        result = filtered_result

    for r in result:
        if r['scan_status'] == "COMPLETE":
            # Go through SBOM statistics and figure out number of packages
            package_counter = 0
            for s in r['sbom_statistics']:
                if len(packagetype_filter) == 0 or s['type'] in packagetype_filter:
                    package_counter = package_counter + s['count']
            r['number_of_packages'] = package_counter

            # Create a vulnerability summary
            r['cves_critical'] = 0
            r['cves_high'] = 0
            r['cves_low'] = 0
            r['cves_medium'] = 0
            r['cves_negligible'] = 0
            r['cves_unknown'] = 0
            r['known_exploits'] = 0
            r['total_risk'] = 0

            for v in r['vulnerability_statistics']:
                severity = v['severity'].lower()
                if (len(fixstatus_filter) == 0 or v['state'] in fixstatus_filter) and (len(packagetype_filter) == 0 or v['type'] in packagetype_filter):
                    r['cves_' + severity] = r['cves_' + severity] + v['count']
                    r['known_exploits'] = r['known_exploits'] + v['known_exploits']
                    r['total_risk'] = r['total_risk'] + v['total_risk']

        del r['sbom_statistics']
        del r['vulnerability_statistics']

    # Sort before returning result
    result.sort(key=partial(sort_scanned_item, sort_field=sort_field, default_sort_fields=["namespace", "pod_name", "container_name"]))

    if output == "csv":
        header_row = [
                        "namespace",
                        "pod_name",
                        "container_name",
                        "image", 
                        "image_id", 
                        "scan_status", 
                        "cves_critical", 
                        "cves_high", 
                        "cves_medium", 
                        "cves_low", 
                        "cves_negligible", 
                        "cves_unknown", 
                        "total_risk", 
                        "known_exploits", 
                        "number_of_packages"
                        ]        
        return generate_csv_response("pod-summary.csv", header_row, result, vulnerability_summary_pod_row_to_csv)
    else:
        return result

def sbom_summary_row_to_csv(row):
    return [
                row['name'],
                row['version'],
                row['type'],
                row['image_count']
            ]

@app.route("/api/sbomsummaryii")
def sbom_summary_ii():
    namespace_filter = request_arg_to_set(request.args.get('namespace'))
    packagetype_filter = request_arg_to_set(request.args.get('packagetype'))
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"sbom_summary_ii({namespace_filter}, {packagetype_filter}, {output})")
    result = get_sbom_summary_ii()

    new_result = []
    for r in result:
        if len(packagetype_filter) == 0 or r['type'] in packagetype_filter:
            namespace_instances = r['namespace_instances']
            tmp_set = set()
            for namespace, image_set in namespace_instances.items():
                if len(namespace_filter) == 0 or namespace in namespace_filter:
                    tmp_set.update(image_set)

            counter = len(tmp_set)
            if counter > 0:
                del r['namespace_instances']
                r['image_count'] = counter
                new_result.append(r)

    # Sort before returning result
    new_result.sort(key=partial(sort_scanned_item, sort_field=sort_field, default_sort_fields=["name", "version"]))

    if output == "csv":
        header_row = [
                        "name",
                        "version",
                        "type",
                        "image_count" 
                        ]        
        return generate_csv_response("sbom-summary.csv", header_row, new_result, sbom_summary_row_to_csv)
    else:
        return new_result

@app.route("/api/hello")
def api_say_hello():
    result = {
        "result": "success"
    }
    strresult=json.dumps(result)
    logger.debug(f"api_say_hello: {strresult}")
    return strresult

@app.route("/api/image/details")
def api_image_details():
    image_id = request.args.get('imageid')
    logger.debug(f"api_image_details({image_id})")
    return get_image_details(image_id)

@app.route("/api/node/details")
def api_node_details():
    node_name = request.args.get('nodename')
    logger.debug(f"api_node_details({node_name})")
    return get_node_details(node_name)

def image_vulnerabilities_row_to_csv(row):
    return [
                row['vulnerability_severity'],
                row['vulnerability_id'],
                row['artifact_name'],
                row['artifact_version'],
                row['vulnerability_fix_versions'],
                row['vulnerability_fix_state'],
                row['artifact_type'],
                row['vulnerability_risk'],
                row['vulnerability_known_exploits']
            ]

@app.route("/api/image/vulnerabilities")
def api_image_vulnerabilities():
    image_id = request.args.get('imageid')
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"api_image_vulnerabilities({image_id} {output})")
    if image_id is None:
        return []

    if output == "json":
        return load_vulnerability_scan_full(image_id)

    result = get_image_vulnerabilties(image_id)

    # Sort before returning result
    result = sort_vulnerability_list(result, sort_field)

    if output == "csv":
        header_row = [
                    "vulnerability_severity",
                    "vulnerability_id",
                    "artifact_name",
                    "artifact_version",
                    "vulnerability_fix_versions",
                    "vulnerability_fix_state",
                    "artifact_type",
                    "vulnerability_risk",
                    "vulnerability_known_exploits"
                    ]        
        return generate_csv_response("image-cve-summary.csv", header_row, result, image_vulnerabilities_row_to_csv)
    else:
        from urllib.parse import urlencode
        for item in result:
            query_params = {
                "imageid": image_id,
                "vulnerabilityid": item["vulnerability_id"],
                "artifactname": item["artifact_name"],
                "artifactversion": item["artifact_version"],
                "artifacttype": item["artifact_type"]
            }
            item["details_url"] = f"/api/image/vulnerabilitydetail?{urlencode(query_params)}"
        return result

@app.route("/api/image/vulnerabilitydetail")
def api_image_vulnerability_detail():
    image_id = request.args.get('imageid')
    vulnerabiity_id = request.args.get('vulnerabilityid')
    artifact_name = request.args.get('artifactname')
    artifact_version = request.args.get('artifactversion')
    artifact_type = request.args.get('artifacttype')
    logger.debug(f"api_image_vulnerability_detail({image_id} {vulnerabiity_id} {artifact_name} {artifact_version} {artifact_type})")

    return get_vulnerability_details(image_id, vulnerabiity_id, artifact_name, artifact_version, artifact_type)

@app.route("/api/node/vulnerabilities")
def api_node_vulnerabilities():
    node_name = request.args.get('nodename')
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"api_node_vulnerabilities({node_name} {output})")
    if node_name is None:
        return []

    if output == "json":
        return load_vulnerability_scan_full(node_name)

    result = get_image_vulnerabilties(node_name)

    # Sort before returning result
    result = sort_vulnerability_list(result, sort_field)

    if output == "csv":
        header_row = [
                    "vulnerability_severity",
                    "vulnerability_id",
                    "artifact_name",
                    "artifact_version",
                    "vulnerability_fix_versions",
                    "vulnerability_fix_state",
                    "artifact_type",
                    "vulnerability_risk",
                    "vulnerability_known_exploits"
                    ]        
        return generate_csv_response("node-cve-summary.csv", header_row, result, image_vulnerabilities_row_to_csv)
    else:
        from urllib.parse import urlencode
        for item in result:
            query_params = {
                "nodename": node_name,
                "vulnerabilityid": item["vulnerability_id"],
                "artifactname": item["artifact_name"],
                "artifactversion": item["artifact_version"],
                "artifacttype": item["artifact_type"]
            }
            item["details_url"] = f"/api/node/vulnerabilitydetail?{urlencode(query_params)}"
        return result

@app.route("/api/node/vulnerabilitydetail")
def api_node_vulnerability_detail():
    node_name = request.args.get('nodename')
    vulnerabiity_id = request.args.get('vulnerabilityid')
    artifact_name = request.args.get('artifactname')
    artifact_version = request.args.get('artifactversion')
    artifact_type = request.args.get('artifacttype')
    logger.debug(f"api_node_vulnerability_detail({node_name} {vulnerabiity_id} {artifact_name} {artifact_version} {artifact_type})")

    return get_vulnerability_details(node_name, vulnerabiity_id, artifact_name, artifact_version, artifact_type)

def api_image_summary_row_to_csv(row):
    return [
                row['namespace'],
                row['scanned_containers'],
                row['avg_cves_critical'],
                row['avg_cves_high'],
                row['avg_cves_medium'],
                row['avg_cves_low'],
                row['avg_cves_negligible'],
                row['avg_cves_unknown'],
                row['avg_risk'],
                row['avg_known_exploits'],
                row['avg_number_of_packages']
            ]

@app.route("/api/image/summary")
def api_image_summary():
    namespace = request.args.get('namespace')
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"api_image_summary({namespace} {output})")
    result = get_image_summary(namespace)
    result.sort(key=partial(sort_scanned_item, sort_field=sort_field, default_sort_fields=["namespace"]))

    if output == "csv":
        header_row = [
                    "namespace",
                    "scanned_containers",
                    "avg_cves_critical",
                    "avg_cves_high",
                    "avg_cves_medium",
                    "avg_cves_low",
                    "avg_cves_negligible",
                    "avg_cves_unknown",
                    "avg_risk",
                    "avg_known_exploits",
                    "avg_number_of_packages"
                    ]        
        return generate_csv_response("image-namespace-summary.csv", header_row, result, api_image_summary_row_to_csv)
    else:
        return result

def api_container_distro_summary_row_to_csv(row):
    return [
                row['distro_id'],
                row['distro_name'],
                row['distro_display_name'],
                row['scanned_containers'],
                row['avg_cves_critical'],
                row['avg_cves_high'],
                row['avg_cves_medium'],
                row['avg_cves_low'],
                row['avg_cves_negligible'],
                row['avg_cves_unknown'],
                row['avg_risk'],
                row['avg_known_exploits'],
                row['avg_number_of_packages']
            ]

@app.route("/api/distro/container-summary")
def api_container_distro_summary():
    namespace = request.args.get('namespace')
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"api_container_distro_summary({namespace} {output})")
    result = get_container_distro_summary(namespace)
    result.sort(key=partial(sort_scanned_item, sort_field=sort_field, default_sort_fields=["distro_display_name"]))

    if output == "csv":
        header_row = [
                    "distro_id",
                    "distro_name",
                    "distro_display_name",
                    "scanned_containers",
                    "avg_cves_critical",
                    "avg_cves_high",
                    "avg_cves_medium",
                    "avg_cves_low",
                    "avg_cves_negligible",
                    "avg_cves_unknown",
                    "avg_risk",
                    "avg_known_exploits",
                    "avg_number_of_packages"
                    ]        
        return generate_csv_response("container-distro-summary.csv", header_row, result, api_container_distro_summary_row_to_csv)
    else:
        return result

def api_node_distro_summary_row_to_csv(row):
    return [
                row['distro_id'],
                row['distro_name'],
                row['distro_display_name'],
                row['scanned_nodes'],
                row['avg_cves_critical'],
                row['avg_cves_high'],
                row['avg_cves_medium'],
                row['avg_cves_low'],
                row['avg_cves_negligible'],
                row['avg_cves_unknown'],
                row['avg_risk'],
                row['avg_known_exploits'],
                row['avg_number_of_packages']
            ]

@app.route("/api/distro/node-summary")
def api_node_distro_summary():
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"api_node_distro_summary({output})")
    result = get_node_distro_summary()
    result.sort(key=partial(sort_scanned_item, sort_field=sort_field, default_sort_fields=["distro_display_name"]))

    if output == "csv":
        header_row = [
                    "distro_id",
                    "distro_name",
                    "distro_display_name",
                    "scanned_nodes",
                    "avg_cves_critical",
                    "avg_cves_high",
                    "avg_cves_medium",
                    "avg_cves_low",
                    "avg_cves_negligible",
                    "avg_cves_unknown",
                    "avg_risk",
                    "avg_known_exploits",
                    "avg_number_of_packages"
                    ]        
        return generate_csv_response("node-distro-summary.csv", header_row, result, api_node_distro_summary_row_to_csv)
    else:
        return result

def image_sbom_row_to_csv(row):
    return [
                row['name'],
                row['version'],
                row['type'],
                row['count']
            ]

@app.route("/api/image/sbom")
def api_image_sbom():
    image_id = request.args.get('imageid')
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"api_image_sbom({image_id}, {output})")
    if image_id is None:
        return []

    if output == "json":
        return load_sbom_full(image_id)

    result = get_image_sbom(image_id)
    result.sort(key=partial(sort_scanned_item, sort_field=sort_field, default_sort_fields=["name", "version"]))

    if output == "csv":
        header_row = [
                        "name",
                        "version",
                        "type",
                        "count"
                    ]        
        return generate_csv_response("image-sbom-summary.csv", header_row, result, image_sbom_row_to_csv)
    else:
        from urllib.parse import urlencode
        for item in result:
            query_params = {
                "imageid": image_id,
                "name": item["name"],
                "version": item["version"],
                "type": item["type"]
            }
            item["details_url"] = f"/api/image/sbomdetail?{urlencode(query_params)}"
        return result

@app.route("/api/image/sbomdetail")
def api_image_sbom_detail():
    image_id = request.args.get('imageid')
    name = request.args.get('name')
    version = request.args.get('version')
    type = request.args.get('type')
    logger.debug(f"api_image_sbom_detail({image_id} {name} {version} {type})")

    return get_sbom_details(image_id, name, version, type)

@app.route("/api/node/sbom")
def api_node_sbom():
    node_name = request.args.get('nodename')
    sort_field = request.args.get('sort')
    output = request.args.get('output')
    logger.debug(f"api_node_sbom({node_name}, {output})")
    if node_name is None:
        return []

    if output == "json":
        return load_sbom_full(node_name)

    result = get_image_sbom(node_name)
    result.sort(key=partial(sort_scanned_item, sort_field=sort_field, default_sort_fields=["name", "version"]))

    if output == "csv":
        header_row = [
                        "name",
                        "version",
                        "type",
                        "count"
                    ]        
        return generate_csv_response("node-sbom-summary.csv", header_row, result, image_sbom_row_to_csv)
    else:
        from urllib.parse import urlencode
        for item in result:
            query_params = {
                "nodename": node_name,
                "name": item["name"],
                "version": item["version"],
                "type": item["type"]
            }
            item["details_url"] = f"/api/node/sbomdetail?{urlencode(query_params)}"
        return result

@app.route("/api/node/sbomdetail")
def api_node_sbom_detail():
    node_name = request.args.get('nodename')
    name = request.args.get('name')
    version = request.args.get('version')
    type = request.args.get('type')
    logger.debug(f"api_node_sbom_detail({node_name} {name} {version} {type})")

    return get_sbom_details(node_name, name, version, type)

@app.route("/api/image/scanstatus")
def api_image_scan_status():
    namespace = request.args.get('namespace')
    logger.debug(f"api_image_scan_status({namespace})")
    return get_image_scan_status(namespace)

@app.route("/api/node/scanstatus")
def api_node_scan_status():
    logger.debug(f"api_node_scan_status()")
    return get_node_scan_status()

@app.route("/")
def index():
    logger.debug("index()")
    return "Congratulations, app up and running!\n"

@app.route("/api/scannerconfig")
def api_get_scanner_config():
    logger.debug("api_get_scanner_config()")
    result = get_scanner_configuration()
    result["clusterName"] = CLUSTER_NAME
    return result

@app.route("/api/admin/resetcontainercache")
def api_admin_reset_container_cache():
    logger.debug("api_admin_reset_container_cache()")
    reset_container_cache()
    return "Started refresh"

@app.route("/api/admin/resetnodecache")
def api_admin_reset_node_cache():
    logger.debug("api_admin_reset_node_cache()")
    reset_node_cache()
    return "Started refresh"

@app.route("/api/admin/rescanimages")
def api_admin_rescan_images():
    logger.debug("api_admin_rescan_images()")
    rescan_all_images()
    return "Started scan"

@app.route("/api/admin/rescannodes")
def api_admin_rescan_nodes():
    logger.debug("api_admin_rescan_nodes()")
    rescan_all_nodes()
    return "Started scan"

@app.route("/api/filters")
def api_get_filters():
    logger.debug("api_get_filters()")
    return get_filters()

@app.route("/api/admin/apicache/status")
def api_get_api_cache_status():
    logger.debug("api_get_api_cache_status()")
    return ApiCache().get_status()

@app.route("/api/admin/apicache/clear")
def api_get_api_cache_clear():
    logger.debug("api_get_api_cache_clear()")
    ApiCache().clear_caches()
    return "Cache cleared"

@app.route("/api/admin/nodetags")
def api_admin_node_tags():
    logger.debug("api_admin_node_tags()")
    from node_tag_cache import NodeTagCache
    cache = NodeTagCache()
    return cache.get_all_node_tags()

@app.route("/metrics")
def api_metrics():
    logger.debug("api_metrics")
    result = generate_metrics()
    return Response("\n".join(result), mimetype="text/plain")

from kubernetes_adapter import get_all_running_containers, init_pod_change_listener, get_all_running_nodes, init_node_change_listener
from pod_scanner import scan_new_image, init_pod_scanner, rescan_image, scan_new_node, rescan_node
from file_manager import load_vulnerability_summary, load_vulnerability_scan, load_sbom, load_scan_status, load_sbom_summary, load_shared_metadata, load_vulnerability_scan_full, load_sbom_full
from scheduler import init_scheduler
import os
import signal
import sys
from app_status_manager import AppStatusManager
from container_cache import Container, ContainerImage, ContainerCache
from node_cache import NodeCache
from node_tag_cache import NodeTagCache
from api_cache import ApiCache, NODE_CACHE_TYPE, IMAGE_CACHE_TYPE
import logging
logger = logging.getLogger(__name__)

RUNNING_CONTAINER_CACHE = ContainerCache()
RUNNING_NODE_CACHE = NodeCache()
RUNNING_NODE_TAG_CACHE = NodeTagCache()
SCAN_NODES = os.getenv("SCAN_NODES", "false").lower() in ("true", "1", "yes")
SCAN_CONTAINERS = os.getenv("SCAN_CONTAINERS", "false").lower() in ("true", "1", "yes")
API_CACHE = ApiCache()

def reset_container_cache():
    logger.info("reset_container_cache")
    running_containers = get_all_running_containers()

    new_running_containers={}
    for running_container in running_containers:
        container = Container(running_container["node_name"], running_container["namespace"], running_container["pod_name"], running_container["container_name"])
        container_instance = ContainerImage(running_container["image"], running_container["image_id"])
        new_running_containers[container] = container_instance
        scan_new_image(running_container["node_name"], running_container["container_id"], running_container["image"], running_container["image_id"])

    #Clear and insert new items
    RUNNING_CONTAINER_CACHE.replace_cache(new_running_containers)

def reset_node_cache():
    logger.info("reset_node_cache")
    running_nodes = get_all_running_nodes()

    for node_name in running_nodes:
        scan_new_node(node_name)

    RUNNING_NODE_CACHE.replace_cache(running_nodes)

def handle_shutdown_signal(signum, frame):
    logger.info(f"handle_shutdown_signal() Received termination signal: {signum}")
    app_status_manager = AppStatusManager()
    app_status_manager.set_is_running(False)
    sys.exit(0)  # Exiting gracefully

def init_scanner():
    logger.info("init_scanner()")
    signal.signal(signal.SIGTERM, handle_shutdown_signal)
    
    #Preload all Kubernetes node tags
    RUNNING_NODE_TAG_CACHE.reset_cache()
    if SCAN_CONTAINERS:
        logger.info("init_scanner() - Setup container scanner")
        #Init the container cache
        reset_container_cache()
        #Listen for pod changes
        init_pod_change_listener(updated_container_callback)
    else:
        logger.info("init_scanner() - Container scanner discabled, skipping")
    
    if SCAN_NODES:
        logger.info("init_scanner() - Setup node scanner")
        #Init the node cache
        reset_node_cache()
        #Listen for node changes
        init_node_change_listener(updated_node_callback)
    else:
        logger.info("init_scanner() - Node scanner discabled, skipping")

    #Init the scheduler
    init_scheduler()
    #Init the pod scanner
    init_pod_scanner()

def updated_container_callback(container_info):
    logger.info(f"updated_container_callback({container_info})")
    cache_event = container_info["cache_event"]
    if cache_event == "ADD":
        logger.debug("Add or modify existing container")
        container = Container(container_info["node_name"], container_info["namespace"], container_info["pod_name"], container_info["container_name"])
        container_instance=ContainerImage(container_info["image"], container_info["image_id"])
        RUNNING_CONTAINER_CACHE.add(container, container_instance)
        scan_new_image(container_info["node_name"], container_info["container_id"], container_info["image"], container_info["image_id"])
    elif cache_event == "DELETE":
        logger.debug("Delete container")
        container = Container(container_info["node_name"], container_info["namespace"], container_info["pod_name"], container_info["container_name"])
        RUNNING_CONTAINER_CACHE.remove(container)
        API_CACHE.clear_caches(IMAGE_CACHE_TYPE)
    else:
        logger.error(f"ERROR updated_container_callback(), unkown event {cache_event}")

def updated_node_callback(node_info):
    logger.info(f"updated_node_callback({node_info})")
    cache_event = node_info["cache_event"]
    node_name = node_info["node_name"]
    if cache_event == "ADD":
        RUNNING_NODE_CACHE.add(node_name)
        #logger.debug(f"updated_node_callback - Added {node_name}")
        scan_new_node(node_name)
    elif cache_event == "DELETE":
        RUNNING_NODE_CACHE.discard(node_name)
        #logger.debug(f"updated_node_callback - Deleted {node_name}")
        API_CACHE.clear_caches(NODE_CACHE_TYPE)
    else:
        logger.error(f"ERROR updated_node_callback(), unkown event {cache_event}")

def sort_vulnerability_summary_by_container(item):
    mapping={
        "COMPLETE": "1",
        "SCANNING": "2",
        "NO_SCAN_AVAILABLE": "3",
        "SCAN_FAILED": "4",
        "TO_BE_SCANNED": "5"
    }

    return mapping[item['scan_status']] + item['image']

def get_vulnerability_details_by_image():
    logger.info("get_vulnerability_details_by_image")
    tmp_result = {}
    for container, container_image in RUNNING_CONTAINER_CACHE.get_copy().items():
        if container_image in tmp_result:
            #Add container to existing resultset
            #logger.debug("Add container to existing resultset")
            value = tmp_result[container_image]
            value["instances"].append(container.get_dict())
        else:
            #Create a new result
            #logger.debug("Create entry to returnset")
            scan_status = load_scan_status(container_image.image_id)
            sbom_statistics = None
            vulnerability_statistics = None
            distro_id = None
            distro_name = None
            distro_display_name = None
            if scan_status == "COMPLETE":
                sbom_summary = load_sbom_summary(container_image.image_id)
                vulnerability_summary = load_vulnerability_summary(container_image.image_id)
                sbom_statistics = sbom_summary['package_statistics']
                vulnerability_statistics = vulnerability_summary['vulnerability_statistics']
                distro_id = get_distro_field(sbom_summary, 'id')
                distro_name = get_distro_field(sbom_summary, 'prettyName')
                distro_display_name = get_distro_display_name(sbom_summary)
            value = {
                "instances": [container.get_dict()],
                "scan_status": scan_status,
                "distro_id": distro_id,
                "distro_name": distro_name,
                "distro_display_name": distro_display_name,
                "sbom_statistics": sbom_statistics,
                "vulnerability_statistics": vulnerability_statistics
            }
            tmp_result[container_image] = value

    result = []
    for container_image, details in tmp_result.items():
        r = {
            "image": container_image.image,
            "image_id": container_image.image_id,
            "scan_status": details['scan_status'],
            "distro_id": details['distro_id'],
            "distro_name": details['distro_name'],
            "distro_display_name": details['distro_display_name'],
            "sbom_statistics": details['sbom_statistics'],
            "vulnerability_statistics": details['vulnerability_statistics'],
            "instances": details['instances']
        }
        result.append(r)

    result.sort(key=sort_vulnerability_summary_by_container)
    return result

def get_namespaces():
    logger.info("get_namespaces()")

    result_set = set()
    for container in RUNNING_CONTAINER_CACHE.get_keys():
        result_set.add(container.namespace)

    return sorted(result_set)

def get_node_distro_display_names():
    logger.info("get_node_distro_display_names()")

    result_set = set()
    for node_name in RUNNING_NODE_CACHE.get_copy():
        scan_status = load_scan_status(node_name)
        if scan_status == "COMPLETE":
            sbom_summary = load_sbom_summary(node_name)
            distro_display_name = get_distro_display_name(sbom_summary)
            result_set.add(distro_display_name)

    return sorted(result_set)

def get_image_distro_display_names():
    logger.info(f"get_image_distro_display_names()")

    result_set = set()
    for container, container_image in RUNNING_CONTAINER_CACHE.get_copy().items():
        scan_status = load_scan_status(container_image.image_id)
        if scan_status == "COMPLETE":
            sbom_summary = load_sbom_summary(container_image.image_id)
            distro_display_name = get_distro_display_name(sbom_summary)
            result_set.add(distro_display_name)

    return sorted(result_set)

def sort_vulnerability_summary_cve(item):
    mapping={
        "Critical": "1",
        "High": "2",
        "Medium": "3",
        "Low": "4",
        "Negligible": "5",
        "Unknown": "6"
    }

    return mapping[item['vulnerability_severity']]+item['vulnerability_id']+item['artifact_name']+item['artifact_version']

def get_vulnerability_summary_by_cve_ii():
    logger.info("get_vulnerability_summary_by_cve_ii()")
    # Figure out what images we have and in what namespaces they're running
    image_info_map = {}
    image_distro_map = {}
    for container, container_image in RUNNING_CONTAINER_CACHE.get_copy().items():
        namespace = container.namespace
        image_id = container_image.image_id
        if image_id not in image_info_map:
            image_info_map[image_id] = set()

        namespace_set = image_info_map[image_id]
        namespace_set.add(namespace)

        # Track distribution for this image_id
        if image_id not in image_distro_map:
            scan_status = load_scan_status(image_id)
            if scan_status == "COMPLETE":
                sbom_summary = load_sbom_summary(image_id)
                image_distro_map[image_id] = get_distro_display_name(sbom_summary)
            else:
                image_distro_map[image_id] = None

    # Load scan for each container
    result_map = {}
    for image_id, namespace_set in image_info_map.items():
        logger.debug(f"Load scan data for image {image_id}")
        cves = load_vulnerability_scan(image_id)
        if cves is None:
            logger.debug(f"Missing scan for image {image_id}, moving on")
        else:
            # Create a tuple that identifies the vulnerability
            for cve in cves:
                #logger.debug(json.dumps(cve))
                tuple_key = (
                            cve['artifact']['name'],
                            cve['artifact']['version'],
                            cve['artifact']['type'],
                            cve['vulnerability']['id'],
                            cve['vulnerability']['severity'],
                            ", ".join(cve['vulnerability']['fix']['versions']),
                            cve['vulnerability']['fix']['state'],
                            cve['vulnerability']['knownExploits'],
                            cve['vulnerability']['risk']
                            )

                if tuple_key not in result_map:
                    result_map[tuple_key] = {}

                tuple_namespace_count_map = result_map[tuple_key]
                for n in namespace_set:
                    if n in tuple_namespace_count_map:
                        tuple_namespace_count_map[n].add(image_id)
                    else:
                        tuple_namespace_count_map[n] = {image_id}

    result = []
    for tuple_key, namespace_instances in result_map.items():
        # Collect all distributions affected by this CVE
        distro_set = set()
        for namespace, image_set in namespace_instances.items():
            for img_id in image_set:
                distro = image_distro_map.get(img_id)
                if distro:
                    distro_set.add(distro)

        row = {
            "artifact_name": tuple_key[0],
            "artifact_version": tuple_key[1],
            "artifact_type": tuple_key[2],
            "vulnerability_id": tuple_key[3],
            "vulnerability_severity": tuple_key[4],
            "vulnerability_fix_versions": tuple_key[5],
            "vulnerability_fix_state": tuple_key[6],
            "vulnerability_known_exploits": tuple_key[7],
            "vulnerability_risk": tuple_key[8],
            "namespace_instances": namespace_instances,
            "distro_set": distro_set
        }
        result.append(row)

    result.sort(key=sort_vulnerability_summary_cve)
    return result

def sort_vulnerability_summary_by_node(item):
    mapping={
        "COMPLETE": "1",
        "SCANNING": "2",
        "NO_SCAN_AVAILABLE": "3",
        "SCAN_FAILED": "4",
        "TO_BE_SCANNED": "5"
    }

    return mapping[item['scan_status']] + item['node_name']

def get_vulnerability_summary_by_node_ii():
    logger.info("get_vulnerability_summary_by_node_ii")

    result = []
    for node_name in RUNNING_NODE_CACHE.get_copy():
        scan_status = load_scan_status(node_name)
        sbom_statistics = None
        vulnerability_statistics = None
        distro_id = None
        distro_name = None
        distro_display_name = None
        if scan_status == "COMPLETE":
            sbom_summary = load_sbom_summary(node_name)
            vulnerability_summary = load_vulnerability_summary(node_name)
            sbom_statistics = sbom_summary['package_statistics']
            vulnerability_statistics = vulnerability_summary['vulnerability_statistics']
            distro_id = get_distro_field(sbom_summary, 'id')
            distro_name = get_distro_field(sbom_summary, 'prettyName')
            distro_display_name = get_distro_display_name(sbom_summary)

        value = {
            "node_name": node_name,
            "distro_id": distro_id,
            "distro_name": distro_name,
            "distro_display_name": distro_display_name,
            "scan_status": scan_status,
            "sbom_statistics": sbom_statistics,
            "vulnerability_statistics": vulnerability_statistics
        }
        result.append(value)

    result.sort(key=sort_vulnerability_summary_by_node)
    return result    

def sort_sbom_summary(item):
    return (item['name']+item['version']).lower();

def get_sbom_summary_ii():
    logger.info(f"get_sbom_summary_ii()")

    # Figure out what images we have and in what namespaces they're running
    image_info_map = {}
    image_distro_map = {}
    for container, container_image in RUNNING_CONTAINER_CACHE.get_copy().items():
        namespace = container.namespace
        image_id = container_image.image_id
        if image_id not in image_info_map:
            image_info_map[image_id] = set()

        namespace_set = image_info_map[image_id]
        namespace_set.add(namespace)

        # Track distribution for this image_id
        if image_id not in image_distro_map:
            scan_status = load_scan_status(image_id)
            if scan_status == "COMPLETE":
                sbom_summary = load_sbom_summary(image_id)
                image_distro_map[image_id] = get_distro_display_name(sbom_summary)
            else:
                image_distro_map[image_id] = None

    # Load scan for each container
    result_map = {}
    for image_id, namespace_set in image_info_map.items():
        logger.debug(f"Load scan data for image {image_id}")
        sbom = load_sbom(image_id)
        if sbom is None:
            logger.debug(f"Missing sbom for image {image_id}, moving on")
        else:
            # Create a tuple that identifies the package
            for artifact in sbom:
                #logger.debug(json.dumps(cve))
                tuple_key = (
                            artifact['name'],
                            artifact['version'],
                            artifact['type']
                            )

                if tuple_key not in result_map:
                    result_map[tuple_key] = {}

                tuple_namespace_count_map = result_map[tuple_key]
                for n in namespace_set:
                    if n in tuple_namespace_count_map:
                        tuple_namespace_count_map[n].add(image_id)
                    else:
                        tuple_namespace_count_map[n] = {image_id}

    result = []
    for tuple_key, namespace_instances in result_map.items():
        # Collect all distributions containing this package
        distro_set = set()
        for namespace, image_set in namespace_instances.items():
            for img_id in image_set:
                distro = image_distro_map.get(img_id)
                if distro:
                    distro_set.add(distro)

        row = {
            "name": tuple_key[0],
            "version": tuple_key[1],
            "type": tuple_key[2],
            "namespace_instances": namespace_instances,
            "distro_set": distro_set
        }
        result.append(row)

    result.sort(key=sort_sbom_summary)
    return result

def sort_pod_summary(item):
    mapping={
        "COMPLETE": "1",
        "SCANNING": "2",
        "NO_SCAN_AVAILABLE": "3",
        "SCAN_FAILED": "4",
        "TO_BE_SCANNED": "5"
    }
    return mapping[item['scan_status']]+item['namespace']+item['pod_name']+item['container_name']

def get_vulnerability_details_by_pod():
    logger.info(f"get_vulnerability_details_by_pod")
    result = []
    for container, container_image in RUNNING_CONTAINER_CACHE.get_copy().items():
        scan_status = load_scan_status(container_image.image_id)
        sbom_statistics = None
        vulnerability_statistics = None
        distro_id = None
        distro_name = None
        distro_display_name = None
        if scan_status == "COMPLETE":
            sbom_summary = load_sbom_summary(container_image.image_id)
            vulnerability_summary = load_vulnerability_summary(container_image.image_id)
            sbom_statistics = sbom_summary['package_statistics']
            vulnerability_statistics = vulnerability_summary['vulnerability_statistics']
            distro_id = get_distro_field(sbom_summary, 'id')
            distro_name = get_distro_field(sbom_summary, 'prettyName')
            distro_display_name = get_distro_display_name(sbom_summary)

        value = {
            "namespace": container.namespace,
            "pod_name": container.pod_name,
            "container_name": container.container_name,
            "image": container_image.image,
            "image_id": container_image.image_id,
            "scan_status": scan_status,
            "distro_id": distro_id,
            "distro_name": distro_name,
            "distro_display_name": distro_display_name,
            "sbom_statistics": sbom_statistics,
            "vulnerability_statistics": vulnerability_statistics
        }
        result.append(value)

    result.sort(key=sort_pod_summary)
    return result

def sort_image_summary(item):
    return item['namespace']+item['pod_name']+item['container_name']

def get_image_details(image_id):
    logger.info(f"get_image_details({image_id})")

    repositories = set()
    instances = []
    for container, container_image in RUNNING_CONTAINER_CACHE.get_copy().items():
        #logger.debug(container_image.image_id)
        if container_image.image_id == image_id:
            repositories.add(container_image.image)
            instances.append(container.get_dict())

    repository_list = list(repositories)
    repository_list.sort()
    instances.sort(key=sort_image_summary)
    scan_status = load_scan_status(image_id)
    distro_display_name = "Unknown"
    if scan_status == "COMPLETE":
        sbom_summary = load_sbom_summary(image_id)
        distro_display_name = get_distro_display_name(sbom_summary)
        
    result = {
        "image_id": image_id,
        "repositories": repository_list,
        "instances": instances,
        "scan_status": scan_status,
        "distro_display_name": distro_display_name
    }

    return result

def get_node_details(node_name):
    logger.info(f"get_node_details({node_name})")

    scan_status = load_scan_status(node_name)
    distro_display_name = "Unknown"
    if scan_status == "COMPLETE":
        sbom_summary = load_sbom_summary(node_name)
        distro_display_name = get_distro_display_name(sbom_summary)
        
    result = {
        "node_name": node_name,
        "scan_status": scan_status,
        "distro_display_name": distro_display_name
    }

    return result

def get_image_vulnerabilties(image_id):
    logger.info(f"get_image_vulnerabilties({image_id})")

    data = load_vulnerability_scan(image_id)
    if data is None:
        return []

    result = []
    # Create a typle that identifies the vulnerability
    for cve in data:
        row = {
            "artifact_name": cve['artifact']['name'],
            "artifact_version": cve['artifact']['version'],
            "artifact_type": cve['artifact']['type'],
            "vulnerability_id": cve['vulnerability']['id'],
            "vulnerability_severity": cve['vulnerability']['severity'],
            "vulnerability_fix_versions": ", ".join(cve['vulnerability']['fix']['versions']),
            "vulnerability_fix_state": cve['vulnerability']['fix']['state'],
            "vulnerability_risk": cve['vulnerability']['risk'],
            "vulnerability_known_exploits": cve['vulnerability']['knownExploits']
        }
        result.append(row)
    result.sort(key=sort_vulnerability_summary_cve)
    return result

def sort_image_summary(item):
    return item['namespace']

def get_image_summary(namespace):
    logger.info(f"get_image_summary({namespace})")

    result_map = {}
    for container, container_image in RUNNING_CONTAINER_CACHE.get_copy().items():
        if namespace is None or namespace == container.namespace:
            scan_status = load_scan_status(container_image.image_id)
            if scan_status == "COMPLETE":
                container_namespace = container.namespace
                vulnerability_summary = load_vulnerability_summary(container_image.image_id)
                if container_namespace in result_map:
                    #Increment numbers
                    curr_value = result_map[container_namespace]
                    tmp_value = {
                        "scanned_containers": curr_value['scanned_containers'] + 1,
                        "cves_critical": curr_value['cves_critical'] + vulnerability_summary['by_severity']['critical'],
                        "cves_high": curr_value['cves_high'] + vulnerability_summary['by_severity']['high'],
                        "cves_medium": curr_value['cves_medium'] + vulnerability_summary['by_severity']['medium'],
                        "cves_low": curr_value['cves_low'] + vulnerability_summary['by_severity']['low'],
                        "cves_negligible": curr_value['cves_negligible'] + vulnerability_summary['by_severity']['negligible'],
                        "cves_unknown": curr_value['cves_unknown'] + vulnerability_summary['by_severity']['unknown'],
                        "risk_total": curr_value['risk_total'] + vulnerability_summary['risk_total'],
                        "known_exploits": curr_value['known_exploits'] + vulnerability_summary['known_exploits'],
                        "number_of_packages": curr_value['number_of_packages'] + vulnerability_summary['number_of_packages']
                    }
                else:
                    #Init result
                    tmp_value = {
                        "scanned_containers": 1,
                        "cves_critical": vulnerability_summary['by_severity']['critical'],
                        "cves_high": vulnerability_summary['by_severity']['high'],
                        "cves_medium": vulnerability_summary['by_severity']['medium'],
                        "cves_low": vulnerability_summary['by_severity']['low'],
                        "cves_negligible": vulnerability_summary['by_severity']['negligible'],
                        "cves_unknown": vulnerability_summary['by_severity']['unknown'],
                        "risk_total": vulnerability_summary['risk_total'],
                        "known_exploits": vulnerability_summary['known_exploits'],
                        "number_of_packages": vulnerability_summary['number_of_packages']
                    }

                result_map[container_namespace] = tmp_value

    result = []
    for ns, data in result_map.items():
        scanned_containers = data['scanned_containers']
        row = {
            "namespace": ns,
        }
        row['scanned_containers'] = scanned_containers
        row['avg_cves_critical'] = data['cves_critical'] / scanned_containers
        row['avg_cves_high'] = data['cves_high'] / scanned_containers
        row['avg_cves_medium'] = data['cves_medium'] / scanned_containers
        row['avg_cves_low'] = data['cves_low'] / scanned_containers
        row['avg_cves_negligible'] = data['cves_negligible'] / scanned_containers
        row['avg_cves_unknown'] = data['cves_unknown'] / scanned_containers
        row['avg_risk'] = data['risk_total'] / scanned_containers
        row['avg_known_exploits'] = data['known_exploits'] / scanned_containers
        row['avg_number_of_packages'] = data['number_of_packages'] / scanned_containers
        result.append(row)
    result.sort(key=sort_image_summary)
    return result

def sort_distro_summary(item):
    return item['distro_name']

def get_distro_display_name(sbom_summary):
    distro_id = get_distro_field(sbom_summary, 'id')
    distro_name = get_distro_field(sbom_summary, 'prettyName')
    if distro_id == "None" and distro_name == "None":
        return "Unknown"
    return distro_name + " (" + distro_id + ")"

def get_distro_field(sbom_summary, field):
    if sbom_summary.get('distro') is None:
        return "None"

    if sbom_summary['distro'].get(field) is None:
        return "None"

    return sbom_summary['distro'][field]

def get_container_distro_summary(namespace):
    logger.info(f"get_container_distro_summary({namespace})")

    result_map = {}
    for container, container_image in RUNNING_CONTAINER_CACHE.get_copy().items():
        if namespace is None or namespace == container.namespace:
            scan_status = load_scan_status(container_image.image_id)
            if scan_status == "COMPLETE":
                vulnerability_summary = load_vulnerability_summary(container_image.image_id)
                sbom_summary = load_sbom_summary(container_image.image_id)
                distro_id = get_distro_field(sbom_summary, 'id')
                distro_name = get_distro_field(sbom_summary, 'prettyName')
                distro_display_name = get_distro_display_name(sbom_summary)
                distro_key = distro_display_name

                tmp_value = {}
                if distro_key in result_map:
                    # Update data
                    curr_value = result_map[distro_key]
                    tmp_value = {
                        "distro_id": curr_value['distro_id'],
                        "distro_name": curr_value['distro_name'],
                        "distro_display_name": curr_value['distro_display_name'],
                        "scanned_containers": curr_value['scanned_containers'] + 1,
                        "cves_critical": curr_value['cves_critical'] + vulnerability_summary['by_severity']['critical'],
                        "cves_high": curr_value['cves_high'] + vulnerability_summary['by_severity']['high'],
                        "cves_medium": curr_value['cves_medium'] + vulnerability_summary['by_severity']['medium'],
                        "cves_low": curr_value['cves_low'] + vulnerability_summary['by_severity']['low'],
                        "cves_negligible": curr_value['cves_negligible'] + vulnerability_summary['by_severity']['negligible'],
                        "cves_unknown": curr_value['cves_unknown'] + vulnerability_summary['by_severity']['unknown'],
                        "risk_total": curr_value['risk_total'] + vulnerability_summary['risk_total'],
                        "known_exploits": curr_value['known_exploits'] + vulnerability_summary['known_exploits'],
                        "number_of_packages": curr_value['number_of_packages'] + vulnerability_summary['number_of_packages']
                    }
                else:
                    tmp_value = {
                        "distro_id": distro_id,
                        "distro_name": distro_name,
                        "distro_display_name": distro_display_name,
                        "scanned_containers": 1,
                        "cves_critical": vulnerability_summary['by_severity']['critical'],
                        "cves_high": vulnerability_summary['by_severity']['high'],
                        "cves_medium": vulnerability_summary['by_severity']['medium'],
                        "cves_low": vulnerability_summary['by_severity']['low'],
                        "cves_negligible": vulnerability_summary['by_severity']['negligible'],
                        "cves_unknown": vulnerability_summary['by_severity']['unknown'],
                        "risk_total": vulnerability_summary['risk_total'],
                        "known_exploits": vulnerability_summary['known_exploits'],
                        "number_of_packages": vulnerability_summary['number_of_packages']
                    }

                result_map[distro_key] = tmp_value

    result = result_map.values()
    for r in result:
        scanned_containers = r['scanned_containers']
        r['avg_cves_critical'] = r['cves_critical'] / scanned_containers
        r['avg_cves_high'] = r['cves_high'] / scanned_containers
        r['avg_cves_medium'] = r['cves_medium'] / scanned_containers
        r['avg_cves_low'] = r['cves_low'] / scanned_containers
        r['avg_cves_negligible'] = r['cves_negligible'] / scanned_containers
        r['avg_cves_unknown'] = r['cves_unknown'] / scanned_containers
        r['avg_risk'] = r['risk_total'] / scanned_containers
        r['avg_known_exploits'] = r['known_exploits'] / scanned_containers
        r['avg_number_of_packages'] = r['number_of_packages'] / scanned_containers
        del r['cves_critical']
        del r['cves_high']
        del r['cves_medium']
        del r['cves_low']
        del r['cves_negligible']
        del r['cves_unknown']
        del r['risk_total']
        del r['known_exploits']
        del r['number_of_packages']

    return sorted(result, key=sort_distro_summary)

def get_node_distro_summary():
    logger.info(f"get_node_distro_summary()")

    result_map = {}
    for node_name in RUNNING_NODE_CACHE.get_copy():
        scan_status = load_scan_status(node_name)
        if scan_status == "COMPLETE":
            vulnerability_summary = load_vulnerability_summary(node_name)
            sbom_summary = load_sbom_summary(node_name)
            distro_id = get_distro_field(sbom_summary, 'id')
            distro_name = get_distro_field(sbom_summary, 'prettyName')
            distro_display_name = get_distro_display_name(sbom_summary)
            distro_key = distro_display_name

            tmp_value = {}
            if distro_key in result_map:
                # Update data
                curr_value = result_map[distro_key]
                tmp_value = {
                    "distro_id": curr_value['distro_id'],
                    "distro_name": curr_value['distro_name'],
                    "distro_display_name": curr_value['distro_display_name'],
                    "scanned_nodes": curr_value['scanned_nodes'] + 1,
                    "cves_critical": curr_value['cves_critical'] + vulnerability_summary['by_severity']['critical'],
                    "cves_high": curr_value['cves_high'] + vulnerability_summary['by_severity']['high'],
                    "cves_medium": curr_value['cves_medium'] + vulnerability_summary['by_severity']['medium'],
                    "cves_low": curr_value['cves_low'] + vulnerability_summary['by_severity']['low'],
                    "cves_negligible": curr_value['cves_negligible'] + vulnerability_summary['by_severity']['negligible'],
                    "cves_unknown": curr_value['cves_unknown'] + vulnerability_summary['by_severity']['unknown'],
                    "risk_total": curr_value['risk_total'] + vulnerability_summary['risk_total'],
                    "known_exploits": curr_value['known_exploits'] + vulnerability_summary['known_exploits'],
                    "number_of_packages": curr_value['number_of_packages'] + vulnerability_summary['number_of_packages']
                }
            else:
                tmp_value = {
                    "distro_id": distro_id,
                    "distro_name": distro_name,
                    "distro_display_name": distro_display_name,
                    "scanned_nodes": 1,
                    "cves_critical": vulnerability_summary['by_severity']['critical'],
                    "cves_high": vulnerability_summary['by_severity']['high'],
                    "cves_medium": vulnerability_summary['by_severity']['medium'],
                    "cves_low": vulnerability_summary['by_severity']['low'],
                    "cves_negligible": vulnerability_summary['by_severity']['negligible'],
                    "cves_unknown": vulnerability_summary['by_severity']['unknown'],
                    "risk_total": vulnerability_summary['risk_total'],
                    "known_exploits": vulnerability_summary['known_exploits'],
                    "number_of_packages": vulnerability_summary['number_of_packages']
                }

            result_map[distro_key] = tmp_value

    result = result_map.values()
    for r in result:
        scanned_nodes = r['scanned_nodes']
        r['avg_cves_critical'] = r['cves_critical'] / scanned_nodes
        r['avg_cves_high'] = r['cves_high'] / scanned_nodes
        r['avg_cves_medium'] = r['cves_medium'] / scanned_nodes
        r['avg_cves_low'] = r['cves_low'] / scanned_nodes
        r['avg_cves_negligible'] = r['cves_negligible'] / scanned_nodes
        r['avg_cves_unknown'] = r['cves_unknown'] / scanned_nodes
        r['avg_risk'] = r['risk_total'] / scanned_nodes
        r['avg_known_exploits'] = r['known_exploits'] / scanned_nodes
        r['avg_number_of_packages'] = r['number_of_packages'] / scanned_nodes
        del r['cves_critical']
        del r['cves_high']
        del r['cves_medium']
        del r['cves_low']
        del r['cves_negligible']
        del r['cves_unknown']
        del r['risk_total']
        del r['known_exploits']
        del r['number_of_packages']

    return sorted(result, key=sort_distro_summary)

def sort_sbom_summary(item):
    return (item['name']+item['version']).lower()

def get_image_sbom(image_id):
    logger.info(f"get_image_sbom({image_id})")

    data = load_sbom(image_id)
    if data is None:
        return []
    else:
        data.sort(key=sort_sbom_summary)
        return data

def rescan_all_images():
    logger.info("rescan_all_images()")

    image_id_set = set()

    for images in RUNNING_CONTAINER_CACHE.get_values():
        image_id_set.add(images.image_id)

    for image_id in image_id_set:
        rescan_image(image_id)

def rescan_all_nodes():
    logger.info("rescan_all_nodes()")

    for node_name in RUNNING_NODE_CACHE.get_copy():
        rescan_node(node_name)

def get_image_scan_status(namespace):
    logger.info(f"get_image_scan_status({namespace})")

    all_statuses = ["COMPLETE", "SCANNING", "TO_BE_SCANNED", "NO_SCAN_AVAILABLE", "SCAN_FAILED"]

    result_map = {}

    for s in all_statuses:
        result_map[s] = 0

    for container, container_image in RUNNING_CONTAINER_CACHE.get_copy().items():
        if namespace is None or namespace == container.namespace:
            scan_status = load_scan_status(container_image.image_id)
            if scan_status in result_map:
                counter = result_map[scan_status]
                result_map[scan_status] = counter + 1
            else:
                result_map[scan_status] = 1

    result = {}
    for status, counter in result_map.items():
        result = {
            status: counter,
            **result
        }

    return result

def get_node_scan_status():
    logger.info("get_node_scan_status")

    all_statuses = ["COMPLETE", "SCANNING", "TO_BE_SCANNED", "NO_SCAN_AVAILABLE", "SCAN_FAILED"]

    result_map = {}

    for s in all_statuses:
        result_map[s] = 0

    for node_name in RUNNING_NODE_CACHE.get_copy():
        scan_status = load_scan_status(node_name)
        if scan_status in result_map:
            counter = result_map[scan_status]
            result_map[scan_status] = counter + 1
        else:
            result_map[scan_status] = 1

    result = {}
    for status, counter in result_map.items():
        result = {
            status: counter,
            **result
        }

    return result

def get_filters():
    logger.info("get_filters")
    result = load_shared_metadata()
    result['namespaces'] = get_namespaces()

    return result

def get_scanner_configuration():
    logger.info("get_scanner_configuration()")
    return {
        "scanContainers": SCAN_CONTAINERS,
        "scanNodes": SCAN_NODES
    }

def get_node_list():
    logger.info("get_host_list()")
    return list(RUNNING_NODE_CACHE.get_copy())

def get_image_id_list():
    logger.info("get_image_id_list()")
    tmpset = set()
    for image in RUNNING_CONTAINER_CACHE.get_values():
        tmpset.add(image.image_id)

    return list(tmpset)

def get_vulnerability_details(image_id, vulnerability_id, artifact_name, artifact_version, artifact_type):
    logger.info(f"get_vulnerability_details({image_id} {vulnerability_id} {artifact_name} {artifact_version} {artifact_type})")
    
    result = load_vulnerability_scan_full(image_id)
    
    if not result or "matches" not in result:
        logger.error(f"get_vulnerability_details() - No scan file for {image_id}")
        return []

    # Filter matches based on the input criteria
    filtered_matches = [
        match for match in result["matches"]
        #print(match.get("artifact", {}).get("version"))
        if match.get("vulnerability", {}).get("id") == vulnerability_id and
           match.get("artifact", {}).get("name") == artifact_name and
           match.get("artifact", {}).get("version") == artifact_version and
           match.get("artifact", {}).get("type") == artifact_type
    ]

    return filtered_matches

def get_sbom_details(image_id, name, version, type):
    logger.info(f"get_sbom_details({image_id} {name} {version} {type})")
    
    result = load_sbom_full(image_id)
    
    if not result or "artifacts" not in result:
        logger.error(f"get_sbom_details() - No SBOM file for {image_id}")
        return []

    # Filter matches based on the input criteria
    filtered_matches = [
        match for match in result["artifacts"]
        if match.get("name") == name and
           match.get("version") == version and
           match.get("type") == type
    ]

    return filtered_matches

from kubernetes import client, config, watch
import threading
import os
import time
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import json
import traceback
from app_status_manager import AppStatusManager
import logging
logger = logging.getLogger(__name__)

CURRENT_NAMESPACE = os.getenv("CURRENT_NAMESPACE")
SCANNER_APP_NAME = os.getenv("SCANNER_APP_NAME")
SCANNER_IP_CACHE = {}

# Load in-cluster Kubernetes configuration
config.load_incluster_config()

def reformat_image_info(image, image_id):
    logger.debug(f"reformat_image_info({image}, {image_id})")
    ignore_start = "docker-pullable://"
    if(image_id.startswith(ignore_start)):
        image_id = image_id[len(ignore_start):]

    result = None
    if image.startswith("sha256:"):
        result =  {
            "image": image_id,
            "image_id": extract_sha256(image_id)
        }
    else:
        result =  {
            "image": image,
            "image_id": extract_sha256(image_id)
        }
    logger.debug(f"reformat_image_info({image}, {image_id}) - result {result}")
    return result    


def get_all_running_containers():
    logger.debug("get_all_running_containers()")

    # Create a Kubernetes API client
    v1 = client.CoreV1Api()

    result=[]
    all_pods = v1.list_pod_for_all_namespaces(field_selector="status.phase=Running")
    for pod in all_pods.items:
        #print(pod)
        for container_status in pod.status.container_statuses:
            image_info = reformat_image_info(container_status.image, container_status.image_id)
            container_info={
                "namespace": pod.metadata.namespace,
                "pod_name": pod.metadata.name,
                "container_name": container_status.name,
                "node_name": pod.spec.node_name,
                "container_id": container_status.container_id,
                "image": image_info['image'],
                "image_id": image_info['image_id']
            }
            result.append(container_info)

    #logger.debug("Result:")
    #logger.debug(json.dumps(result))
    return result

def get_all_running_nodes():
    logger.debug("get_all_running_nodes")
    # Create a Kubernetes API client
    v1 = client.CoreV1Api()

    result = set()
    nodes = v1.list_node()
    for node in nodes.items:
        for condition in node.status.conditions:
            if condition.type == "Ready" and condition.status == "True":
                result.add(node.metadata.name)
    
    return result

def init_pod_change_listener(callback_function):
    logger.info("init_pod_change_listener()")
    listener_thread = threading.Thread(target=pod_change_listener, args = [callback_function])
    listener_thread.start()

def pod_change_listener(callback_function):
    logger.info("pod_change_listener()")
    app_status_manager = AppStatusManager()
    
    v1 = client.CoreV1Api()
    w = watch.Watch()
    resource_version = None
    
    while app_status_manager.is_running():
        try:
            # Set up a watch on pod resources
            stream = None
            if resource_version == None:
                stream = w.stream(v1.list_pod_for_all_namespaces, timeout_seconds=5)
            else:
                stream = w.stream(v1.list_pod_for_all_namespaces, timeout_seconds=5, resource_version=resource_version)

            for event in stream:
                if app_status_manager.is_running() == False:
                    #The application is shutting down, stop processing events
                    return
                
                process_pod_change(callback_function, event)
                #Update the resource version to make sure we're not missing any events
                resource_version = event['object'].metadata.resource_version

            #print("Error - pod_change_listener ended, restarting")
        except Exception as e:
            print(f"Error - pod_change_listener encountered an exception: {e}, restarting")
            resource_version = None
            traceback.print_exc()

def process_pod_change(callback_function, event_data):
    logger.info("process_pod_change()")
    event_type = event_data['type'] 
    pod_data = event_data['object']
    namespace = pod_data.metadata.namespace
    pod_name = pod_data.metadata.name
    node_name= pod_data.spec.node_name

    if pod_data.status.container_statuses is not None:
        for container_status in pod_data.status.container_statuses:
            container_name = container_status.name
            container_id = container_status.container_id
            image = container_status.image
            image_id = container_status.image_id
            image_info = reformat_image_info(image, image_id)
            image_ready = container_status.ready
            image_phase = pod_data.status.phase
            if image_ready == True and event_type != "DELETED":
                cache_event = "ADD"
            else:
                cache_event = "DELETE"
            event_info={
                "cache_event": cache_event,
                "namespace": namespace,
                "pod_name": pod_name,
                "container_name": container_name,
                "node_name": node_name,
                "container_id": container_id,
                "image": image_info['image'],
                "image_id": image_info['image_id']
            }
            if cache_event == "ADD" and container_id and image and image_id:
                callback_function(event_info)
            elif cache_event == "DELETE":
                callback_function(event_info)
            else:
                print("ERROR - Insufficient data")
                print(event_info)

def init_node_change_listener(callback_function):
    logger.info("init_node_change_listener()")
    listener_thread = threading.Thread(target=node_change_listener, args = [callback_function])
    listener_thread.start()

def node_change_listener(callback_function):
    logger.info("node_change_listener()")
    app_status_manager = AppStatusManager()
    
    v1 = client.CoreV1Api()
    w = watch.Watch()
    resource_version = None
    
    while app_status_manager.is_running():
        try:
            # Set up a watch on pod resources
            stream = None
            if resource_version == None:
                stream = w.stream(v1.list_node, timeout_seconds=5)
            else:
                stream = w.stream(v1.list_node, timeout_seconds=5, resource_version=resource_version)

            for event in stream:
                if app_status_manager.is_running() == False:
                    #The application is shutting down, stop processing events
                    return
                
                process_node_change(callback_function, event)
                #Update the resource version to make sure we're not missing any events
                resource_version = event['object'].metadata.resource_version

            #print("Error - pod_change_listener ended, restarting")
        except Exception as e:
            print(f"Error - pod_change_listener encountered an exception: {e}, restarting")
            resource_version = None
            traceback.print_exc()

def process_node_change(callback_function, event_data):
    logger.info("process_node_change()")
    event_type = event_data['type'] #DELETED ADDED MODIFIED
    node_info = event_data['object']
    node_name = node_info.metadata.name

    ready_state = "Unknown"
    for condition in node_info.status.conditions:
        if condition.type == "Ready":
            ready_state = condition.status
            break

    #logger.debug(f"{node_name}: {event_type}, Ready: {ready_state}")

    if event_type == "DELETED":
        cache_event = "DELETE"
    elif event_type == "ADDED" or event_type == "MODIFIED":
        if ready_state == "True":
            cache_event = "ADD"
        else:
            cache_event = "DELETE"
    else:
        logger.error(f"process_node_change() ERROR - Unknown event {event_type}")
        logger.error(event_data)
        return None

    event_info={
        "cache_event": cache_event,
        "node_name": node_name
    }

    callback_function(event_info)

def extract_sha256(input_string):
    logger.debug(f"extract_sha256({input_string})")
    # Check if the string contains "@"
    result = None
    if '@' in input_string:
        # Split the string at "@" and return the second part
        result = input_string.split('@')[1]
    else:
        # If "@" is not present, return the original string
        result = input_string
    logger.debug(f"extract_sha256({input_string}) result: {result}")
    return result

def get_scanner_ip(node_name):
    logger.debug(f"get_scanner_ip({node_name})")
    if node_name in SCANNER_IP_CACHE:
        result = SCANNER_IP_CACHE[node_name]
        if result is None:
            # Most likely a control node, return None
            return result
        else:
            # Check if the node still works
            remote_node = say_hello_to_scanner(result)
            if remote_node == node_name:
                return result
            else:
                # Scanner service has changed, rebuild cache and return
                logger.info("Scanner service has changed, rebuild cache and return")
                reset_pod_scanner_cache()
                return SCANNER_IP_CACHE[node_name]
    else:
        reset_pod_scanner_cache()
        return SCANNER_IP_CACHE[node_name]

def say_hello_to_scanner(ip):
    logger.debug(f"say_hello_to_scanner({ip})")
    url = "http://"+ip+":8080/hello"

    session = requests.Session()
    retry_strategy = Retry(
        total=1,  # Number of total retries
        backoff_factor=1,  # Time to wait between retries (exponential backoff)
        status_forcelist=[429, 500, 502, 503, 504]
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)

    try:
        response = session.get(url, timeout=5)
        if response.status_code == 200:
            json_result = response.json()
            #print(f"Data: {json_result}")
            return json_result["node_name"]
        else:
            logger.error(f"say_hello_to_scanner({ip}) Failed with error {response.status_code}")
            return None
    except requests.exceptions.RequestException as e:
        logger.error(f"say_hello_to_scanner({ip}) Request failed: {e}")
        return None


def reset_pod_scanner_cache():
    logger.info("reset_pod_scanner_cache()")
    v1 = client.CoreV1Api()
    new_cache = {}
    while len(new_cache) == 0:
        pods = v1.list_namespaced_pod(CURRENT_NAMESPACE, label_selector="app="+SCANNER_APP_NAME)
        if len(pods.items) == 0:
            print("No scanner pods, wait and retry")
            time.sleep(5)
        else:
            all_pods_running = True

            for pod in pods.items:
                if not pod.status.phase == "Running":
                    logger.debug("Pod not ready, wait and retry")
                    all_pods_running = False
                else:
                    is_running = False
                    for condition in pod.status.conditions:
                        if condition.type == "Ready" and condition.status == "True":
                            is_running = True
                            break
                    if is_running == False:
                        logger.debug("Pod not ready, wait and retry")
                        all_pods_running = False

            if not all_pods_running:
                logger.debug("Not all pods are running, wait and retry")
                time.sleep(5)
            else:
                for pod in pods.items:
                    node_name = pod.spec.node_name
                    pod_ip = pod.status.pod_ip
                    #logger.debug(f"Adding {node_name}: {pod_ip}")
                    new_cache[node_name] = pod_ip
                    #logger.debug(new_cache)

    #Check if there are nodes out there that's not a part of the daemon-set
    all_node_names = get_node_names()
    for node_name in all_node_names:
        if node_name not in new_cache:
            #If it's not there, add it anyway with a None value
            new_cache[node_name] = None    

    SCANNER_IP_CACHE.clear()
    SCANNER_IP_CACHE.update(new_cache)

def get_node_names():
    logger.debug("get_node_names()")
    v1 = client.CoreV1Api()
    nodes = v1.list_node()
    result = []

    for node in nodes.items:
        #logger.debug(node)
        result.append(node.metadata.name)
    
    return result

def load_node_tags(node_name):
    logger.debug(f"load_node_tags({node_name})")
    scanner_ip = get_scanner_ip(node_name)
    logger.debug(f"load_node_tags scanner ip: {scanner_ip}")
    if scanner_ip is None:
        # Returning nothing if we have nowhere to call
        logger.error(f"get_node_tags failed on node {node_name}")
        return {}
    
    # Call SBOM Service
    url = f"http://{scanner_ip}:8080/nodetags"

    try:
        # Send a GET request to the service
        logger.debug("load_node_tags - Start")
        response = requests.get(url)
        
        # Check if the request was successful
        if response.status_code == 200:
            return response.json()
        else:
            logger.error(f"Failed with status code: {response.status_code}")
            return {}
    except requests.exceptions.RequestException as e:
        # Handle any errors that occur during the request
        logger.error(f"Request failed: {e}")
        traceback.print_exc()
        return {}

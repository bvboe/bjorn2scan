import threading
from kubernetes_adapter import load_node_tags, get_all_running_nodes

class NodeTagCache:
    _instance = None
    _lock = threading.Lock()  # Ensures thread safety during instance creation

    def __new__(cls):
        #Ensure only one instance of NodeTagCache exists.
        if cls._instance is None: 
            with cls._lock:
                if not cls._instance:
                    cls._instance = super().__new__(cls)
                    cls._instance._cache = {}  # Initialize cache
                    cls._instance._lock = threading.Lock()  # Lock for thread safety
        return cls._instance

    def get_node_tags(self, node_name):
        #Retrieve node tags from cache, or load them if missing.
        with self._lock:
            if node_name not in self._cache:
                self._cache[node_name] = load_node_tags(node_name)
            return self._cache[node_name].copy()

    def get_all_node_tags(self):
        #Return a copy of all cached node tags to prevent race conditions.
        with self._lock:
            return dict(self._cache)

    def delete_node_tags(self, node_name):
        #Remove node tags from the cache.
        with self._lock:
            if node_name in self._cache:
                del self._cache[node_name]

    def refresh_node_tags(self, node_name):
        #Force refresh of node tags by reloading them.
        with self._lock:
            self._cache[node_name] = load_node_tags(node_name)

    def reset_cache(self):
        new_cache = {}
        for node_name in get_all_running_nodes():
            new_cache[node_name] = load_node_tags(node_name)

        with self._lock:
            self._cache = new_cache
